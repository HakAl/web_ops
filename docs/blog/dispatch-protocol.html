<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="We built three AI teams that worked great alone but couldn't coordinate. The fix was a filesystem protocol from 1995.">
    <title>Our AI Teams Had a Communication Problem (The Fix Was From 1995) - The Skills Team</title>
    <link rel="canonical" href="https://hakal.github.io/web_ops/blog/dispatch-protocol.html">
    <meta property="og:title" content="Our AI Teams Had a Communication Problem (The Fix Was From 1995)">
    <meta property="og:description" content="We built three AI teams that worked great alone but couldn't coordinate. The fix was a filesystem protocol from 1995.">
    <meta property="og:url" content="https://hakal.github.io/web_ops/blog/dispatch-protocol.html">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="The Skills Team">
    <meta property="og:image" content="https://hakal.github.io/web_ops/blog/winner_1.jpg">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Our AI Teams Had a Communication Problem (The Fix Was From 1995)">
    <meta name="twitter:description" content="We built three AI teams that worked great alone but couldn't coordinate. The fix was a filesystem protocol from 1995.">
    <meta name="twitter:image" content="https://hakal.github.io/web_ops/blog/winner_1.jpg">
    <link rel="icon" type="image/svg+xml" href="../favicon.svg">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../style.css">
</head>
<body>
    <header class="hero hero-small">
        <h1>Our AI Teams Had a Communication Problem (The Fix Was From 1995)</h1>
        <p class="blog-meta">February 2026</p>
        <p><a href="./">&larr; Back to blog</a></p>
    </header>

    <div class="blog-hero-img">
        <img src="winner_1.jpg" alt="Diagram showing the dispatch protocol: three stages from draft to delivered to processed, connected by dotted arrows" width="1280" height="720" loading="eager">
    </div>

    <main>
        <article class="section blog-post">
            <p>We built three AI teams. An engineering team that designs and builds. A web ops team that writes and publishes. A QA team that tests and validates.</p>

            <p>Each team works in its own repo, runs during its own sessions, has its own lead. Inside a session, they're sharp &mdash; planning, critiquing, building, reviewing. The personas collaborate in shared context, challenging each other in real time.</p>

            <p>Then engineering finished a feature and needed web ops to write about it.</p>

            <p>No mechanism. No channel. No way for one team to tell another team "there's work for you" without the user remembering to pass the message manually.</p>

            <p>We'd built silos.</p>

            <h2>The Problem Isn't Obvious at Three Teams</h2>

            <p>With one team, communication isn't a problem &mdash; everything happens in one session. With two, you can keep it in your head. Three is where it breaks. The user becomes the message bus, and the message bus forgets.</p>

            <p>The real failure mode isn't dropped messages. It's <em>invisible</em> dropped messages. Engineering ships a feature. Web ops doesn't know. The blog goes stale. Nobody notices because no system tracks what was supposed to happen.</p>

            <h2>We Looked at What Everyone Else Does</h2>

            <p>We surveyed the major multi-agent frameworks &mdash; AutoGen, CrewAI, LangGraph, MetaGPT. Every one assumes agents that are always running.</p>

            <p>The academic literature was more useful. Confluent's analysis of multi-agent architectures identifies the <strong>blackboard pattern</strong>: a shared space where agents post and retrieve information. No direct communication. Agents decide autonomously whether to act on what they read.</p>

            <p>That fit. But every implementation we found assumed daemons, brokers, pub-sub &mdash; agents listening for events in real time.</p>

            <p>Our agents don't run between sessions.</p>

            <h2>Why Standard Advice Didn't Apply</h2>

            <p>This is the part the frameworks don't account for: our agents are session-based. They exist only when a human starts a Claude Code session. Between sessions, nothing is running. No process, no daemon, no listener.</p>

            <p>The literature strongly favors event-driven architectures for multi-agent systems. Confluent, HiveMQ, AWS &mdash; they all say the same thing: events reduce connection complexity, enable real-time responsiveness, decouple agents via pub-sub.</p>

            <p>All true. All irrelevant.</p>

            <p>You can't send an event to a process that doesn't exist. And you can't justify a message broker for three teams that run a few sessions a day.</p>

            <p><strong>Polling on session start is correct</strong> for this model. Not because it's better than events &mdash; it's not &mdash; but because it's the only thing that works when agents are ephemeral. You check your inbox when you arrive at the office. You don't need a push notification system if you open your email every morning.</p>

            <p>Microsoft's own multi-agent reference architecture acknowledges that message-driven patterns introduce "complexity managing correlation IDs, idempotency, message ordering, and workflow state." That overhead buys nothing in our model.</p>

            <h2>The Fix Was From 1995</h2>

            <p>Daniel J. Bernstein designed Maildir around 1995 to solve a specific problem: how do you deliver email safely on a filesystem without locks, without corruption, without losing messages if the system crashes mid-write?</p>

            <p>His answer was three directories:</p>

<pre><code>tmp/   &mdash; message being written (never read by consumers)
new/   &mdash; delivered, not yet seen
cur/   &mdash; seen and processed</code></pre>

            <p>The protocol: write the complete message to <code>tmp/</code>. When it's fully written, rename it to <code>new/</code>. The rename is atomic &mdash; consumers never see a partial file. When a consumer reads it, move it to <code>cur/</code>.</p>

            <p>Two words, per Bernstein: "no locks."</p>

            <p>This is exactly what we needed. Replace "email" with "dispatch" and "mail server" with "team inbox":</p>

<pre><code>~/.team/dispatch/
  engineering/
    tmp/     # dispatch being written
    new/     # delivered, unread
    cur/     # read and processed
  web_ops/
    tmp/
    new/
    cur/
  qa/
    tmp/
    new/
    cur/</code></pre>

            <p>Engineering writes a dispatch to <code>web_ops/tmp/</code>. Renames it to <code>web_ops/new/</code>. Next time web ops starts a session, Dana checks <code>web_ops/new/</code>, reads it, moves it to <code>cur/</code>, and creates a local tracking issue.</p>

            <p>No broker. No database. No network. Just files and directories.</p>

            <h2>Design Decisions That Mattered</h2>

            <p>Building the protocol exposed choices that looked small but shaped everything:</p>

            <p><strong>Dispatches are notifications, not conversations.</strong> The natural instinct is to add replies, threading, acknowledgments. Research on cross-team coordination warned us: "Jira-as-communication" &mdash; using tickets as the sole cross-team channel &mdash; kills actual coordination. Dispatches say "there's work for you." Discussion happens live, with the user present.</p>

            <p><strong>Everything in the file.</strong> A dispatch is a Markdown file with YAML frontmatter. Here's what the first real one looked like:</p>

<pre><code>---
from: engineering
to: web_ops
priority: normal
status: pending
created: 2026-01-31
related_bead: _skills-73r
---

## Update Site for Resume Skills

All 6 Web Ops team members now have baseline resume
skills. Site should reflect the new capabilities.

### Acceptance
Blog post or site update referencing the new skills.</code></pre>

            <p>The filename encodes the metadata: <code>2026-01-31T14-30-00Z_normal_engineering_update-site.md</code> &mdash; timestamp, priority, origin, slug. You can <code>ls</code> the inbox and triage without parsing YAML.</p>

            <p><strong>No reassignment.</strong> "Hot potato ownership" &mdash; tickets bounced between teams &mdash; is a known anti-pattern. A dispatch is a request. The receiver decides whether to accept. If it's wrong, delete it and route correctly.</p>

            <p><strong>Cadence triggers, not cron.</strong> Teams define recurring dispatches in a table. The lead checks it on session start, sends what's due. No scheduler. Three teams don't need infrastructure.</p>

            <h2>Independent Validation</h2>

            <p>While researching, we found <code>agent-message-queue</code> &mdash; an open-source project that independently implemented nearly the same design:</p>

<pre><code>.agent-mail/
  agents/
    claude/
      inbox/{tmp,new,cur}/
      outbox/sent/</code></pre>

            <p>Same Maildir lifecycle. Same filesystem medium. Same structured frontmatter. They added acknowledgments and threading &mdash; features we deliberately excluded at our scale.</p>

            <p>When two teams solve the same problem and converge on the same architecture without knowing about each other, that's signal.</p>

            <h2>What We Shipped</h2>

            <p>The dispatch protocol is live. The <code>/team</code> skill checks all inboxes on startup and shows a one-line summary. Each team lead polls their inbox on session start. The first real dispatch &mdash; engineering asking web ops to update the site for new resume skills &mdash; went through the system cleanly.</p>

            <p>The entire implementation is:</p>
            <ul>
                <li>Three directories per team (9 total)</li>
                <li>One YAML frontmatter format</li>
                <li>One filename convention</li>
                <li>Session-start polling in the <code>/team</code> skill</li>
                <li>A table in TEAM.md for cadence triggers</li>
            </ul>

            <p>No code. No dependencies. No services to maintain. The protocol is the implementation.</p>

            <h2>What We Learned</h2>

            <p><strong>The right architecture was 30 years old.</strong> We surveyed modern multi-agent frameworks, event-driven systems, and agent interop protocols. The answer was a filesystem pattern from the qmail era. Sometimes the best technology is the one that already solved your exact problem.</p>

            <p><strong>Constraints drive good design.</strong> "Our agents don't run between sessions" felt like a limitation. It turned out to be the constraint that eliminated complexity. No broker, no pub-sub, no daemon &mdash; because we couldn't have them. What remained was simple enough to be correct.</p>

            <p><strong>Don't build conversations.</strong> Every instinct says "add replies." The research on cross-team coordination says conversations in ticket systems are where coordination goes to die. One-way notifications with live discussion when needed.</p>

            <p><strong>Independent convergence is the strongest validation.</strong> We didn't find <code>agent-message-queue</code> until after designing the protocol. Finding it after &mdash; same architecture, same patterns, same medium &mdash; was more convincing than any benchmark.</p>

            <p><strong>Simple doesn't mean trivial.</strong> Nine directories and a naming convention. But the design drew on blackboard architectures, Maildir specifications, cross-team coordination research, and filesystem IPC patterns. Simple outputs require understanding the problem deeply enough to throw away the complex solutions.</p>

            <p>The protocol is 30 years old. The problem is brand new. It works anyway.</p>
        </article>
    </main>

    <footer>
        <p>
            <a href="https://github.com/HakAl/team_skills">GitHub</a> &middot;
            <a href="../">Home</a> &middot;
            Built by the Skills Team
        </p>
    </footer>
</body>
</html>
